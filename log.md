# 日志 #

**本日志记录本人跟着 *《30天自制操作系统》* 这本书实现一个自己的操作系统的点点滴滴** <br>

## 记录内容 ##

### 2025/7/13 ##

- 完成day0任务

     1.明确使用c语言与汇编语言来开发自己的os <br>
     2.了解各章概要并且明确每周要干的事

- 完成day1任务

     1.认识二进制编辑器**bz** <br>
     2.在**bz**中输入相应内容生成.img文件 <br>
     3.使用**qemu**模拟器，运行.img文件，实现“hello-world" <br>
     4.使用汇编编译器代替**bz**，.nas文件缩短了代码行数，实现3中功能 <br>
     5.认识汇编语言中的基本命令（DB,DW,DD）

### 2025/7/14 ###

- 完成day2任务

     1.了解helloos.nas中的部分内容：新指令，cpu寄存器，内存 <br>
     2.使用c语言改写helloos.nas中的部分内容 <br>
     3.将helloos.nas中的部分内容截去，制作启动区 <br>
     4.学习了更加便捷的批处理文件-**makefile**,可以在一个文件中定义多个命令，并且执行一个命令会把准备命令执行（即自动生成该命令所需的文件），**makefile**还能根据文件内容是否被更新来决定是否生成新的文件

### 2025/7/15 ###

- 完成day3任务

     1.制作真正的**IPL**（启动区），复习磁盘知识，了解缓冲区知识 <br>
     2.学习了汇编语言中的错误处理方法：使用计数寄存器和跳转指令，若不出错则跳出，出错则将计数器+1，进行磁盘复位，然后再次读取，若出错次数超过规定次数，跳转至error <br>
     3.了解了读取到磁盘不同区域的方法(缓冲区地址表示方法：[ES:BX]，即ES×16+BX的内存地址) <br>
     4.向一个空软盘保存文件时：文件名会写在0x002600以后的地方：文件的内容会写在0x004200以后的地方 <br>
     5.学习如何将os内容装载至.sys文件并在启动区启动.sys文件
     6.进入32位模式导入c语言前，先将所要调用的BIOS信息全部装载入内存中 <br>
     7.导入c语言

- 完成day4任务

     1.学习使用汇编语言和c语言向特定内存地址写入内容 <br>
     2.学习了c语言指针进阶的部分内容，即指针的引用和解引用 <br>
     3.复习指针知识：指针的赋值，指针变量更应该叫做地址变量，以及访存的各种写法 <br>
     4.利用逻辑运算绘制出条纹图案 <br>
     5.使用8位图像模式定义出16种需要使用的颜色 <br>
     6.使用像素点坐标与vram坐标对应公式绘制出矩形，加以调整绘制出os初步界面

### 2025/7/16 ###

- 完成day5任务

     1.使用指针取得vram相应参数，避免写死 <br>
     2.使用结构体保存图像显示基本信息 <br>
     3.使用 8x16 的点阵数组通过按位与的方式显示字符 <br>
     4.更改字符来源，使用hankaku.txt中的字符 <br>
     5.改进字符函数，实现显示字符串的函数 <br>
     6.使用**sprintf**函数和显示字符函数来显示变量值 <br>
     7.在字符显示函数和变量值显示的基础上绘制鼠标指针以及鼠标坐标 <br>
     8.实现对**gdt**(全局段号记录表)和**idt**(中断记录表)的定义和初始化

### 2025/7/17 ###

- 完成day6任务

     1.将my_bootpack.c分隔成多个源文件 <br>
     2.添加头文件my_bootpack.h <br>
     3.修改makefile中内容，使用一般规则，更加高效 <br>
     4.初始化pic(可编程中断) <br>
     5.实现键盘回显 <br>
     6.实现本地部署并且运行 <br>
     **在本地部署，需要随着书本内容而不断更新，切记要先看完书本相应内容再更新代码，不要急躁，之后结合代码比对应用会更加高效**
     **添加新的c源文件需要在makefile中声明，让目标文件进行链接；nasfuction.nas中增加新函数要在my_bootpack.h中声明以调用**
     ~~**今天因为急躁，直接运行make.run,真的走了很多弯路。**~~

### 2025/7/18 ###

- 完成day7任务

     1.修改my_int.c使得键盘输入时，屏幕上能够回显输入的键值 <br>
     2.将中断处理和输入回显分开 <br>
     3.使用队列思想建立缓冲区 <br>
     4.修改队列为循环队列 <br>
     5.初始化键盘控制电路并且激活鼠标 <br>
     **最近几天效率比较低**

### 2025/7/19 ###

- 完成day8任务

     1.修改**my_bootpack.c**使得移动鼠标时，屏幕上能够回显鼠标的操作键值(操作类型和位置) <br>
     2.优化代码结构 <br>
     3.根据鼠标键值高亮鼠标操作(左、中、右键),显示鼠标位置 <br>
     4.通过重新绘制鼠标指针实现指针移动，但是覆盖未完成 <br>
     5.详解**asmhead.nas**文件内容

- 完成day9任务

     1.优化代码结构 <br>
     2.通过禁止缓存实现空余内存容量显示 <br>
     3.使用“从xxx号地址开始的yyy字节的空间是空着的”的思想进行内存管理，实现内存分配、合并和释放

### 2025/7/20 ###

- 完成day10任务

     1.添加**my_memory.c**，优化文件结构 <br>
     2.修改**my_memory.c**，处理外碎片问题，（以0x1000为单位） <br>
     3.学习了以二进制数为基础的向上向下舍入，使用按位与&，向下直接与"100"，向上先加"99"再与"100" <br>
     4.十进制数舍入公式：i = i (+-) (i % a);i是操作数，a是舍去单位 <br>
     5.引入**my_sheet.c**，通过设定和更改图层高度，使用图层更新替换掉鼠标绘制函数来实现图层移动和叠加处理 <br>
     6.修改图层更新函数，使其可以定义更新的范围，即实现部分更新，并且优化代码结构，进行剪枝来提高更新效率

### 2025/7/21 ###

- 完成day11任务

     1.修改右方和下方坐标限制，实现指针的隐藏 <br>
     2.添加refresh在屏幕的坐标限制 <br>
     3.为每个图层添加所属图层组的信息，减少函数的参数 <br>
     4.绘制窗口 <br>
     5.将窗口内容改为计数器 <br>
     6.优化刷新逻辑，可以指定刷新的起始层 <br>
     7.利用map来保存画面上每个像素点所属的图层，现在可以指定刷新的层数范围 <br> 
     **尝试统一refreshsub和refreshmap,给后者添加上界** <br>
     ~~经过测试后，两者是能够统一的~~

### 2025/7/22 ###

- 完成day12任务

     1.新增定时器模块 <br>
     2.设定中断周期为11932，使得中断频率为100hz <br>
     3.将中断计数器写入窗口中 <br>
     4.实现超时功能，即超过一定时间后向定时器缓冲区写入数据，让屏幕上有回显 <br>
     5.设定多个超时定时器，利用短时间的定时器来模拟光标闪烁 <br>
     6.优化超时中断处理，减少减法运算和if语句的执行 <br>
     7.引入**下一个时间点**的概念，未到下一个时间点之前可以不用进行超时中断处理 <br>
     8.仿照图层处理优化超时中断逻辑

### 2025/7/23 ###

- 完成day13任务

     1.将几个显示字符串的函数组合在一起制作出新函数 <br>
     2.将缓冲区内存由**char**指针改成**int**指针，大小由**8**位扩展到**32**位，同时将不同类型的缓冲区整合成一个缓冲区，并且明确分隔不同类型输入的键值范围 <br>
     3.使用链表的思想修改**timer**和**timerctl**结构体，使用链表插入法改写定时函数 <br>
     4.引入“哨兵”优化插入逻辑 <br>

### 2025/7/24 ###

- 完成day14任务

     1.优化链表结构 <br>
     2.切换到不使用VBE的画面模式时用“AH = 0；AL=画面模式号码；”，而切换到使用VBE的画面模式时用“AX = 0x4f02；BX = 画面模式号码；”。 <br>
     3.现在可以自由切换高分辨率(适配显卡)和低分辨率模式(320x200x8bit) <br>
     4.实现键盘输入回显，实现文本框输入 <br>
     5.实现鼠标移动窗口 <br>

### 2025/7/25 ###

- 完成day15任务

     1.优化链表结构 <br>
     2.通过分配时间片方式实现任务不停切换

- 完成day16任务

     1.实现任务统一管理 <br>
     2.实现空闲任务休眠 <br>
     3.增加处理任务数量（出现bug）

### bug修复 ###

**目前的定时器逻辑会因为重复插入导致链表成环，任务切换会卡住。**

目前的解决方案：定时函数前加入判断重复插入的逻辑，但这种方案并非最佳解决方案 <br>
当前查找出的重复插入的定时器不是task_timer <br>
最终结果：重复插入的定时器是**光标定时器**，它在没有超时的情况下被再次定时 <br>

### 2025/8/3 ###

- 完成day16任务

     1.设定任务优先级以及独立时间片 <br>
     2.修复文本框bug

- 完成day17任务

     1.设定任务优先级以及独立时间片 <br>
     2.绘制命令行窗口

### 2025/8/10 ###

- 完成day17任务

     1.通过调整窗口标题颜色实现窗口切换 <br>
     2.向任务中加入缓冲区实现字符输入 <br>
     3.处理**shift**键以实现符号输入,准备两种状态的字符 <br>
     4.实现大小写输入 <br>
     5.支持各种锁定键 

- 完成day18任务

     1.区分窗口类型， 控制光标只在当前窗口闪烁<br>
     2.处理命令行对回车的支持 <br>
     3.实现窗口随输出滚动 <br>
     4.实现**mem,cls,dir**命令

## 2025/8/11 ###

- 完成day19任务

     1.实现**type**命令 <br>
     2.通过处理**FAT**（文件分配表）对文件进行读取 <br>
     3.整理代码

- 完成day20任务

     1.用汇编语言实现显示单个字符的API<br>
     2.实现API出口 <br>
     3.能够处理不同文件名 <br>
     4.防止程序擅自修改寄存器内容 <br>
     5.升级API，使其能显示字符串

## 2025/8/12 ###

- 完成day21任务

     1.通过指定数据段修复字符串API的BUG <br>
     2.使用c语言编写字符串API <br>
     3.指定操作系统和应用程序内存空间，禁止应用程序访问系统内存段 

## 2025/8/13 ###

- 完成day22任务

     1.实现强制结束应用程序功能 <br>
     2.完善c语言字符串API <br>
     3.实现显示窗口的API  <br>
     4.在窗口上显示字符和图形

## 2025/8/14 ###

- 完成day23任务

     1.为API编写**malloc**函数，减少空闲内存消耗 <br>
     2.在窗口上绘制点和线，同时优化刷新逻辑，绘制图形完毕后再统一刷新 <br>
     3.实现显示窗口的API  <br>
     4.程序结束后关闭窗口（隐藏窗口图层并释放） <br>
     5.通过定时器和键盘输入控制窗口关闭 <br>
     6.加入强制退出键

## 2025/8/15 ###

- 完成day24任务

     1.通过鼠标和键盘输入进行窗口切换 <br>
     2.实现对所有窗口的鼠标移动 <br>
     3.使用鼠标来关闭窗口 <br>
     4.调整光标闪烁使其与当前窗口同步 <br>
     5.实现定时器API <br>
     6.在定时器API结束时同时取消定时器

## 2025/8/16 ###

- 完成day25任务

     1.实现在模拟器上不支持的蜂鸣器发声 <br>
     2.增加颜色至232种 <br>
     3.增加色阶使得颜色显示更加平滑 <br>
     4.调整窗口初始位置 <br>
     5.实现同时运行多个命令行窗口 <br>
     6.区分不同命令行窗口启动的API所分配的段号

## 2025/8/17 ###

- 完成day26任务

     1.优化refresh逻辑以提高窗口移动速度 <br>
     2.启动时只打开一个窗口 <br>
     3.动态分配命令行窗口资源 <br>
     4.实现命令行窗口两种方式的关闭（键盘输入和鼠标） <br>
     5.实现**start**命令和**ncst**命令 

## 2025/8/18 ###

- 完成day27任务

     1.唤醒休眠任务使其结束解决**ncst**命令bug <br>
     2.通过先隐藏命令行窗口实现执行应用程序时关闭命令行窗口 <br>
     3.引入**LDT**（局部中断表）,将应用程序段设置在独立的LDT中,其他程序无法访问 <br>
     4.进行API函数拆分 <br>
     5.将拆分好的函数组成一个库 <br>
     6.整理文件树 

## 2025/8/19 ###

- 完成day28任务

     1.编写**alloc**函数以申请超过4k的栈内存 <br>
     2.实现文件操作API(未完成写文件功能) <br>
     3.实现获取命令行输入内容API <br>
     4.实现半角和全角字符的显示 

## 2025/8/20 ###

- 完成day29任务

     1.修改字符刷新逻辑 <br>
     2.实现文件压缩(tek格式) <br>
     3.开始编写标准函数 <br>
     4.绘制任意形状的窗口 <br>
     5.画线成球 <br>
     6.制作外星人入侵游戏 

## 2025/8/21 ###

- 完成day30任务

     1.实现命令行计算器 <br>
     2.实现文本阅览器 <br>
     3.实现**MML**音乐播放器 <br>
     4.实现图片阅览器 <br>
     5.缩小应用程序大小,减少读盘时间 <br>
     6.光盘启动 

## 之后的改进目标 ###

1.完善文件系统,增加文件修改和删除操作 <br>
2.引入**UTF-8**编码以实现各种语言的显示